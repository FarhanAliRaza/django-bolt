from __future__ import annotations

from importlib import import_module
from pathlib import Path
from typing import Iterable, List, Dict

from .inspector import ModelInfo


def _stub_header() -> str:
    return "# Auto-generated by django-bolt types. Do not edit manually.\n\n"


def _needs_datetime_import(mi: ModelInfo) -> bool:
    for f in mi.fields:
        if f.py_type.startswith("datetime."):
            return True
    return False


def _emit_model_stub(mi: ModelInfo) -> str:
    lines: List[str] = []
    lines.append(_stub_header())
    lines.append("from __future__ import annotations\n")
    lines.append("from typing import Optional\n")
    lines.append("from django_bolt.typecheck import TypedQuerySet, TypedManager\n")
    lines.append("from django.db.models import Model\n\n")
    if _needs_datetime_import(mi):
        lines.insert(4, "import datetime\n")

    # Model class with annotated fields (best-effort)
    lines.append(f"class {mi.name}(Model):\n")
    if not mi.fields:
        lines.append("    ...\n\n")
    else:
        for f in mi.fields:
            t = f.py_type
            if f.optional:
                t = f"Optional[{t}]"
            lines.append(f"    {f.name}: {t}\n")
        # Manager attribute inside class for better attribute typing
        mn = f"{mi.name}Manager"
        lines.append(f"    objects: {mn}\n")
        # Instance methods from Model base class
        lines.append(f"    def save(self, force_insert: bool = ..., force_update: bool = ..., using: str | None = ..., update_fields: list[str] | None = ...) -> None: ...\n")
        lines.append(f"    def delete(self, using: str | None = ...) -> tuple[int, dict[str, int]]: ...\n")
        lines.append(f"    def refresh_from_db(self, using: str | None = ..., fields: list[str] | None = ...) -> None: ...\n")
        lines.append(f"    async def asave(self, force_insert: bool = ..., force_update: bool = ..., using: str | None = ..., update_fields: list[str] | None = ...) -> None: ...\n")
        lines.append(f"    async def adelete(self, using: str | None = ...) -> tuple[int, dict[str, int]]: ...\n")
        lines.append(f"    async def arefresh_from_db(self, using: str | None = ..., fields: list[str] | None = ...) -> None: ...\n")
        lines.append("\n")

    # Typed queryset and manager with equality lookups and lightweight extras
    qn = f"{mi.name}QuerySet"
    mn = f"{mi.name}Manager"
    lines.append(f"class {qn}(TypedQuerySet[{mi.name}]):\n")
    # filter/get signatures with named kwargs for known fields
    arglist_qs = ""
    if mi.fields:
        # Build kwargs signature: field: Optional[type] = ...
        kw_pairs_qs: List[str] = []
        for f in mi.fields:
            t = f.py_type
            opt_t = f"Optional[{t}]"
            for fname in f.filter_names:
                kw_pairs_qs.append(f"{fname}: {opt_t} = ...")
        arglist_qs = ", ".join(kw_pairs_qs)
        lines.append(f"    def filter(self, *, {arglist_qs}) -> {qn}: ...\n")
        lines.append(f"    def exclude(self, *, {arglist_qs}) -> {qn}: ...\n")
        # get: fields optional at signature level, but returns model
        lines.append(f"    def get(self, *, {arglist_qs}) -> {mi.name}: ...\n")
    else:
        lines.append("    ...\n")
    # common queryset sugar with loose typing
    lines.append(f"    def only(self, *fields: str) -> {qn}: ...\n")
    lines.append(f"    def values(self, *fields: str) -> list[dict[str, object]]: ...\n")
    lines.append(f"    def values_list(self, *fields: str, flat: bool = ...) -> list[object] | list[tuple[object, ...]]: ...\n")
    # update with typed field validation
    update_arglist = ""
    if mi.fields:
        # Build kwargs for update - use actual field types, not Optional
        kw_pairs_update: list[str] = []
        for f in mi.fields:
            t = f.py_type
            # For update, we want the actual type since we're setting values
            kw_pairs_update.append(f"{f.name}: {t} = ...")
        update_arglist = ", ".join(kw_pairs_update)
        lines.append(f"    def update(self, *, {update_arglist}) -> int: ...\n")
    else:
        lines.append(f"    def update(self, **kwargs) -> int: ...\n")
    lines.append(f"    def delete(self) -> tuple[int, dict[str, int]]: ...\n")
    lines.append(f"    def order_by(self, *fields: str) -> {qn}: ...\n")
    lines.append(f"    def distinct(self, *fields: str) -> {qn}: ...\n")
    lines.append(f"    def select_related(self, *fields: str) -> {qn}: ...\n")
    lines.append(f"    def prefetch_related(self, *fields: str) -> {qn}: ...\n")
    # async methods
    if mi.fields:
        # Use the same arglist from sync methods
        lines.append(f"    async def aget(self, *, {arglist_qs}) -> {mi.name}: ...\n")
        lines.append(f"    async def acreate(self, **kwargs) -> {mi.name}: ...\n")
        lines.append(f"    async def aupdate(self, *, {update_arglist}) -> int: ...\n")
        lines.append(f"    async def adelete(self) -> tuple[int, dict[str, int]]: ...\n")
        lines.append(f"    async def afirst(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def alast(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def acount(self) -> int: ...\n")
        lines.append(f"    async def aexists(self) -> bool: ...\n")
    else:
        lines.append(f"    async def aget(self, **kwargs) -> {mi.name}: ...\n")
        lines.append(f"    async def acreate(self, **kwargs) -> {mi.name}: ...\n")
        lines.append(f"    async def aupdate(self, **kwargs) -> int: ...\n")
        lines.append(f"    async def adelete(self) -> tuple[int, dict[str, int]]: ...\n")
        lines.append(f"    async def afirst(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def alast(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def acount(self) -> int: ...\n")
        lines.append(f"    async def aexists(self) -> bool: ...\n")
    lines.append("\n")
    lines.append(f"class {mn}(TypedManager[{mi.name}]):\n")
    arglist_mgr = ""
    if mi.fields:
        kw_pairs_mgr: List[str] = []
        for f in mi.fields:
            t = f.py_type
            opt_t = f"Optional[{t}]"
            for fname in f.filter_names:
                kw_pairs_mgr.append(f"{fname}: {opt_t} = ...")
        arglist_mgr = ", ".join(kw_pairs_mgr)
        lines.append(f"    def filter(self, *, {arglist_mgr}) -> {qn}: ...\n")
        lines.append(f"    def exclude(self, *, {arglist_mgr}) -> {qn}: ...\n")
        lines.append(f"    def get(self, *, {arglist_mgr}) -> {mi.name}: ...\n")
    else:
        lines.append("    ...\n")
    # mirror sugar on manager for common patterns
    lines.append(f"    def only(self, *fields: str) -> {qn}: ...\n")
    lines.append(f"    def values(self, *fields: str) -> list[dict[str, object]]: ...\n")
    lines.append(f"    def values_list(self, *fields: str, flat: bool = ...) -> list[object] | list[tuple[object, ...]]: ...\n")
    # async methods on manager
    if mi.fields:
        # Use the same arglist from sync methods
        lines.append(f"    async def aget(self, *, {arglist_mgr}) -> {mi.name}: ...\n")
        lines.append(f"    async def acreate(self, **kwargs) -> {mi.name}: ...\n")
        lines.append(f"    async def aget_or_create(self, **kwargs) -> tuple[{mi.name}, bool]: ...\n")
        lines.append(f"    async def aupdate_or_create(self, **kwargs) -> tuple[{mi.name}, bool]: ...\n")
        lines.append(f"    async def abulk_create(self, objs: list[{mi.name}], **kwargs) -> list[{mi.name}]: ...\n")
        lines.append(f"    async def abulk_update(self, objs: list[{mi.name}], fields: list[str], **kwargs) -> int: ...\n")
        lines.append(f"    async def acount(self) -> int: ...\n")
        lines.append(f"    async def afirst(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def alast(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def aexists(self) -> bool: ...\n")
    else:
        lines.append(f"    async def aget(self, **kwargs) -> {mi.name}: ...\n")
        lines.append(f"    async def acreate(self, **kwargs) -> {mi.name}: ...\n")
        lines.append(f"    async def aget_or_create(self, **kwargs) -> tuple[{mi.name}, bool]: ...\n")
        lines.append(f"    async def aupdate_or_create(self, **kwargs) -> tuple[{mi.name}, bool]: ...\n")
        lines.append(f"    async def abulk_create(self, objs: list[{mi.name}], **kwargs) -> list[{mi.name}]: ...\n")
        lines.append(f"    async def abulk_update(self, objs: list[{mi.name}], fields: list[str], **kwargs) -> int: ...\n")
        lines.append(f"    async def acount(self) -> int: ...\n")
        lines.append(f"    async def afirst(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def alast(self) -> {mi.name} | None: ...\n")
        lines.append(f"    async def aexists(self) -> bool: ...\n")
    lines.append("\n")

    return "".join(lines)


def _emit_app_types_stub(models: List[ModelInfo]) -> str:
    lines: List[str] = []
    lines.append(_stub_header())
    lines.append("from __future__ import annotations\n")
    lines.append("from typing import Optional\n")
    lines.append("from django_bolt.typecheck import TypedQuerySet, TypedManager\n\n")
    # Import model classes for generic parameters
    for mi in models:
        lines.append(f"from .models import {mi.name}\n")
    lines.append("\n")

    for mi in models:
        qn = f"{mi.name}QuerySet"
        mn = f"{mi.name}Manager"
        lines.append(f"class {qn}(TypedQuerySet[{mi.name}]):\n")
        if mi.fields:
            kw_pairs_qs2: List[str] = []
            for f in mi.fields:
                t = f.py_type
                opt_t = f"Optional[{t}]"
                for fname in f.filter_names:
                    kw_pairs_qs2.append(f"{fname}: {opt_t} = ...")
            arglist = ", ".join(kw_pairs_qs2)
            lines.append(f"    def filter(self, *, {arglist}) -> {qn}: ...\n")
            lines.append(f"    def exclude(self, *, {arglist}) -> {qn}: ...\n")
            lines.append(f"    def get(self, *, {arglist}) -> {mi.name}: ...\n")
        else:
            lines.append("    ...\n")
        lines.append("\n")

        lines.append(f"class {mn}(TypedManager[{mi.name}]):\n")
        if mi.fields:
            kw_pairs_mgr2: List[str] = []
            for f in mi.fields:
                t = f.py_type
                opt_t = f"Optional[{t}]"
                for fname in f.filter_names:
                    kw_pairs_mgr2.append(f"{fname}: {opt_t} = ...")
            arglist = ", ".join(kw_pairs_mgr2)
            lines.append(f"    def filter(self, *, {arglist}) -> {qn}: ...\n")
            lines.append(f"    def exclude(self, *, {arglist}) -> {qn}: ...\n")
            lines.append(f"    def get(self, *, {arglist}) -> {mi.name}: ...\n")
        else:
            lines.append("    ...\n")
        lines.append("\n")

    return "".join(lines)


def emit_model_stubs(models: Iterable[ModelInfo], root: Path, *, overlay: bool = False) -> None:
    """Write .pyi stubs for the given models.

    If overlay is True, writes next to the source module (e.g., users/models.pyi)
    so Pyright will prefer the stub over the .py for analysis. Otherwise, writes
    to the provided stubs root mirroring the package path.
    """
    # Group by module path so we can also emit per-app _types.pyi
    module_to_models: Dict[str, List[ModelInfo]] = {}
    for mi in models:
        bucket = module_to_models.get(mi.module)
        if bucket is None:
            bucket = []
            module_to_models[mi.module] = bucket
        bucket.append(mi)

    for module_path, module_models in module_to_models.items():
        module_parts = module_path.split(".")
        if overlay:
            mod = import_module(module_path)
            src = Path(getattr(mod, "__file__", ""))
            if not src:
                continue
            target_dir = src.parent
        else:
            target_dir = root.joinpath(*module_parts[:-1])

        target_dir.mkdir(parents=True, exist_ok=True)
        # Emit models.pyi per module
        target_file = target_dir / f"{module_parts[-1]}.pyi"
        # If multiple models share same models.py, concatenate content deterministically
        content = "".join(_emit_model_stub(mi) for mi in module_models)
        target_file.write_text(content)

        # Emit _types.pyi for TYPE_CHECKING imports inside models.py
        types_file = target_dir / "_types.pyi"
        types_file.write_text(_emit_app_types_stub(module_models))


